\textbf{üìã Apa yang akan dipelajari}

Pada bab ini kita akan mempelajari tentang design patterns - solusi yang sudah terbukti untuk masalah umum dalam pemrograman:

\begin{itemize}
\item Pengenalan design patterns dan manfaatnya
\item Singleton Pattern - Memastikan hanya ada satu instance
\item Observer Pattern - Komunikasi antar objek
\item MVC Pattern - Memisahkan logika dan tampilan
\item Implementasi design patterns dalam Qt
\item Relevansi signal-slot dengan Observer Pattern
\end{itemize}

\minitoc

\section{üé® Pengenalan Design Patterns}

\subsection{Apa itu Design Pattern?}

Design pattern adalah solusi yang sudah terbukti untuk masalah umum dalam pemrograman berorientasi objek. Pattern ini memberikan template yang bisa digunakan kembali untuk menyelesaikan masalah yang sering muncul.

\begin{quote}
\textit{"Design patterns adalah solusi yang sudah terbukti untuk masalah umum dalam software design."} - Gang of Four
\end{quote}

\subsection{Manfaat Design Patterns}

\begin{itemize}
\item \textbf{Reusability} - Solusi yang bisa digunakan kembali
\item \textbf{Maintainability} - Kode yang mudah dipelihara
\item \textbf{Communication} - Bahasa yang sama antar developer
\item \textbf{Flexibility} - Kode yang fleksibel dan mudah diubah
\item \textbf{Best Practices} - Mengikuti prinsip OOP yang baik
\end{itemize}

\subsection{Kategori Design Patterns}

Design patterns dibagi menjadi tiga kategori utama:

\begin{enumerate}
\item \textbf{Creational Patterns} - Cara membuat objek
\item \textbf{Structural Patterns} - Cara menyusun objek
\item \textbf{Behavioral Patterns} - Cara objek berkomunikasi
\end{enumerate}

\section{üè≠ Singleton Pattern}

\subsection{Pengenalan Singleton}

Singleton pattern memastikan bahwa sebuah class hanya memiliki satu instance dan memberikan akses global ke instance tersebut.

\subsection{Kapan Menggunakan Singleton}

\begin{itemize}
\item \textbf{Database connection} - Satu koneksi untuk seluruh aplikasi
\item \textbf{Configuration manager} - Satu pengaturan untuk seluruh aplikasi
\item \textbf{Logger} - Satu logger untuk seluruh aplikasi
\item \textbf{Cache manager} - Satu cache untuk seluruh aplikasi
\end{itemize}

\subsection{Implementasi Singleton di C++}

\begin{lstlisting}[language=c++, caption=Singleton Pattern Implementation]
#include <iostream>
using namespace std;

class Singleton {
private:
    static Singleton* instance;
    string data;
    
    // Constructor private
    Singleton() {
        data = "Singleton instance created";
    }
    
public:
    // Mencegah copy constructor
    Singleton(const Singleton&) = delete;
    
    // Mencegah assignment operator
    Singleton& operator=(const Singleton&) = delete;
    
    // Method untuk mendapatkan instance
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }
    
    void setData(string value) {
        data = value;
    }
    
    string getData() {
        return data;
    }
    
    void showMessage() {
        cout << "Data: " << data << endl;
    }
};

// Inisialisasi static member
Singleton* Singleton::instance = nullptr;

int main() {
    // Mendapatkan instance
    Singleton* obj1 = Singleton::getInstance();
    obj1->setData("Hello from Singleton!");
    obj1->showMessage();
    
    // Mendapatkan instance yang sama
    Singleton* obj2 = Singleton::getInstance();
    obj2->showMessage(); // Akan menampilkan data yang sama
    
    cout << "obj1 == obj2: " << (obj1 == obj2) << endl; // true
    
    return 0;
}
\end{lstlisting}

\subsection{Singleton dalam Qt}

Qt menggunakan Singleton pattern dalam beberapa komponen:

\begin{lstlisting}[language=c++, caption=Qt Singleton Example]
#include <QApplication>
#include <QCoreApplication>

int main(int argc, char *argv[]) {
    // QApplication adalah singleton
    QApplication app(argc, argv);
    
    // QCoreApplication::instance() memberikan akses ke instance
    QCoreApplication* instance = QCoreApplication::instance();
    
    return app.exec();
}
\end{lstlisting}

\section{üëÅÔ∏è Observer Pattern}

\subsection{Pengenalan Observer}

Observer pattern memungkinkan objek untuk berlangganan (subscribe) ke perubahan yang terjadi pada objek lain. Ketika objek yang diamati berubah, semua observer akan diberitahu.

\subsection{Komponen Observer Pattern}

\begin{itemize}
\item \textbf{Subject} - Objek yang diamati
\item \textbf{Observer} - Objek yang ingin diberitahu
\item \textbf{Notify} - Method untuk memberitahu observer
\item \textbf{Update} - Method yang dipanggil observer
\end{itemize}

\subsection{Implementasi Observer di C++}

\begin{lstlisting}[language=c++, caption=Observer Pattern Implementation]
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Abstract Observer
class Observer {
public:
    virtual void update(string message) = 0;
};

// Concrete Observer
class NewsSubscriber : public Observer {
private:
    string name;
    
public:
    NewsSubscriber(string n) : name(n) {}
    
    void update(string message) override {
        cout << name << " received: " << message << endl;
    }
};

// Subject
class NewsAgency {
private:
    vector<Observer*> observers;
    string news;
    
public:
    void attach(Observer* observer) {
        observers.push_back(observer);
    }
    
    void detach(Observer* observer) {
        // Remove observer dari vector
        for (auto it = observers.begin(); it != observers.end(); ++it) {
            if (*it == observer) {
                observers.erase(it);
                break;
            }
        }
    }
    
    void notify() {
        for (Observer* observer : observers) {
            observer->update(news);
        }
    }
    
    void setNews(string n) {
        news = n;
        notify(); // Notify semua observer
    }
};

int main() {
    NewsAgency agency;
    
    NewsSubscriber* alice = new NewsSubscriber("Alice");
    NewsSubscriber* bob = new NewsSubscriber("Bob");
    NewsSubscriber* charlie = new NewsSubscriber("Charlie");
    
    // Attach observers
    agency.attach(alice);
    agency.attach(bob);
    agency.attach(charlie);
    
    // Set news - semua observer akan diberitahu
    agency.setNews("Breaking: C++ is awesome!");
    
    // Detach observer
    agency.detach(bob);
    
    // Set news lagi - hanya Alice dan Charlie yang diberitahu
    agency.setNews("Update: Qt is powerful!");
    
    return 0;
}
\end{lstlisting}

\section{üîó Signal-Slot sebagai Observer Pattern}

\subsection{Relevansi Signal-Slot dengan Observer}

Qt's signal-slot mechanism adalah implementasi dari Observer pattern. Signal berperan sebagai Subject, dan Slot berperan sebagai Observer.

\subsection{Implementasi Signal-Slot}

\begin{lstlisting}[language=c++, caption=Signal-Slot Implementation]
#include <QObject>
#include <QPushButton>
#include <QLabel>
#include <QVBoxLayout>
#include <QWidget>

class MyWidget : public QWidget {
    Q_OBJECT
    
private:
    QPushButton* button;
    QLabel* label;
    int counter = 0;
    
public:
    MyWidget(QWidget* parent = nullptr) : QWidget(parent) {
        // Setup UI
        QVBoxLayout* layout = new QVBoxLayout(this);
        
        button = new QPushButton("Click Me!", this);
        label = new QLabel("Counter: 0", this);
        
        layout->addWidget(button);
        layout->addWidget(label);
        
        // Connect signal to slot (Observer pattern)
        connect(button, SIGNAL(clicked()), this, SLOT(onButtonClicked()));
    }
    
private slots:
    void onButtonClicked() {
        counter++;
        label->setText("Counter: " + QString::number(counter));
    }
};
\end{lstlisting}

\subsection{Keunggulan Signal-Slot}

\begin{itemize}
\item \textbf{Loose coupling} - Signal dan slot tidak saling mengenal
\item \textbf{Type safety} - Compile-time checking
\item \textbf{Automatic memory management} - Qt menangani cleanup
\item \textbf{Thread safety} - Bisa digunakan di multi-threading
\end{itemize}

\section{üèóÔ∏è MVC Pattern}

\subsection{Pengenalan MVC}

Model-View-Controller (MVC) adalah pattern yang memisahkan aplikasi menjadi tiga komponen:

\begin{itemize}
\item \textbf{Model} - Data dan business logic
\item \textbf{View} - Tampilan user interface
\item \textbf{Controller} - Menangani input dan mengupdate model/view
\end{itemize}

\subsection{Implementasi MVC Sederhana}

\begin{lstlisting}[language=c++, caption=MVC Pattern Implementation]
#include <iostream>
#include <string>
#include <vector>
using namespace std;

// Model - Data dan business logic
class StudentModel {
private:
    vector<string> students;
    
public:
    void addStudent(string name) {
        students.push_back(name);
    }
    
    void removeStudent(string name) {
        for (auto it = students.begin(); it != students.end(); ++it) {
            if (*it == name) {
                students.erase(it);
                break;
            }
        }
    }
    
    vector<string> getAllStudents() {
        return students;
    }
    
    int getStudentCount() {
        return students.size();
    }
};

// View - Tampilan
class StudentView {
public:
    void displayStudents(vector<string> students) {
        cout << "=== Daftar Mahasiswa ===" << endl;
        for (int i = 0; i < students.size(); i++) {
            cout << (i + 1) << ". " << students[i] << endl;
        }
        cout << "Total: " << students.size() << " mahasiswa" << endl;
        cout << "========================" << endl;
    }
    
    void displayMessage(string message) {
        cout << "Info: " << message << endl;
    }
};

// Controller - Menangani input dan mengupdate model/view
class StudentController {
private:
    StudentModel* model;
    StudentView* view;
    
public:
    StudentController(StudentModel* m, StudentView* v) : model(m), view(v) {}
    
    void addStudent(string name) {
        model->addStudent(name);
        view->displayMessage("Mahasiswa " + name + " ditambahkan");
        view->displayStudents(model->getAllStudents());
    }
    
    void removeStudent(string name) {
        model->removeStudent(name);
        view->displayMessage("Mahasiswa " + name + " dihapus");
        view->displayStudents(model->getAllStudents());
    }
    
    void showAllStudents() {
        view->displayStudents(model->getAllStudents());
    }
};

int main() {
    StudentModel model;
    StudentView view;
    StudentController controller(&model, &view);
    
    // Menambah mahasiswa
    controller.addStudent("Alice");
    controller.addStudent("Bob");
    controller.addStudent("Charlie");
    
    // Menghapus mahasiswa
    controller.removeStudent("Bob");
    
    return 0;
}
\end{lstlisting}

\subsection{MVC dalam Qt}

Qt menggunakan konsep MVC dalam beberapa komponen:

\begin{lstlisting}[language=c++, caption=Qt MVC Example]
#include <QApplication>
#include <QListView>
#include <QStringListModel>
#include <QVBoxLayout>
#include <QPushButton>
#include <QWidget>

class StudentManager : public QWidget {
    Q_OBJECT
    
private:
    QStringListModel* model;
    QListView* view;
    QPushButton* addButton;
    QPushButton* removeButton;
    
public:
    StudentManager(QWidget* parent = nullptr) : QWidget(parent) {
        // Model
        QStringList students;
        students << "Alice" << "Bob" << "Charlie";
        model = new QStringListModel(students, this);
        
        // View
        view = new QListView(this);
        view->setModel(model);
        
        // Controller (buttons)
        addButton = new QPushButton("Add Student", this);
        removeButton = new QPushButton("Remove Student", this);
        
        // Layout
        QVBoxLayout* layout = new QVBoxLayout(this);
        layout->addWidget(view);
        layout->addWidget(addButton);
        layout->addWidget(removeButton);
        
        // Connect signals to slots
        connect(addButton, SIGNAL(clicked()), this, SLOT(addStudent()));
        connect(removeButton, SIGNAL(clicked()), this, SLOT(removeStudent()));
    }
    
private slots:
    void addStudent() {
        QStringList list = model->stringList();
        list << "New Student";
        model->setStringList(list);
    }
    
    void removeStudent() {
        QModelIndex currentIndex = view->currentIndex();
        if (currentIndex.isValid()) {
            model->removeRow(currentIndex.row());
        }
    }
};
\end{lstlisting}

\section{üéØ Best Practices Design Patterns}

\subsection{Kapan Menggunakan Design Patterns}

\begin{itemize}
\item \textbf{Gunakan ketika diperlukan} - Jangan over-engineer
\item \textbf{Pahami masalah terlebih dahulu} - Pattern bukan solusi ajaib
\item \textbf{Pertimbangkan kompleksitas} - Pattern bisa menambah kompleksitas
\item \textbf{Dokumentasikan penggunaan} - Jelaskan mengapa pattern digunakan
\end{itemize}

\subsection{Anti-Patterns}

\begin{itemize}
\item \textbf{God Object} - Satu class yang melakukan segalanya
\item \textbf{Spaghetti Code} - Kode yang tidak terstruktur
\item \textbf{Golden Hammer} - Menggunakan satu pattern untuk semua masalah
\item \textbf{Over-Engineering} - Solusi yang terlalu kompleks
\end{itemize}

\section{üîß Implementasi Design Patterns dalam Qt}

\subsection{Qt's Built-in Patterns}

Qt sudah mengimplementasikan beberapa design patterns:

\begin{itemize}
\item \textbf{Signal-Slot} - Observer Pattern
\item \textbf{QApplication} - Singleton Pattern
\item \textbf{Model-View} - MVC Pattern
\item \textbf{QObject} - Composite Pattern
\item \textbf{QThread} - Strategy Pattern
\end{itemize}

\subsection{Contoh Implementasi Custom Pattern}

\begin{lstlisting}[language=c++, caption=Custom Observer dalam Qt]
#include <QObject>
#include <QString>
#include <QList>

// Abstract Observer
class Observer : public QObject {
    Q_OBJECT
    
public:
    virtual void update(const QString& message) = 0;
};

// Subject
class Subject : public QObject {
    Q_OBJECT
    
private:
    QList<Observer*> observers;
    QString state;
    
public:
    void attach(Observer* observer) {
        observers.append(observer);
    }
    
    void detach(Observer* observer) {
        observers.removeOne(observer);
    }
    
    void setState(const QString& newState) {
        state = newState;
        notify();
    }
    
    QString getState() const {
        return state;
    }
    
private slots:
    void notify() {
        for (Observer* observer : observers) {
            observer->update(state);
        }
    }
};

// Concrete Observer
class ConcreteObserver : public Observer {
    Q_OBJECT
    
private:
    QString name;
    
public:
    ConcreteObserver(const QString& n) : name(n) {}
    
    void update(const QString& message) override {
        qDebug() << name << "received:" << message;
    }
};
\end{lstlisting}

\section{üìö Referensi dan Bacaan Lanjutan}

Untuk pemahaman yang lebih mendalam tentang design patterns, pembaca dapat merujuk pada:

\begin{itemize}
\item \textbf{Design Patterns: Elements of Reusable Object-Oriented Software} - Gang of Four\footnote{Gamma, E., Helm, R., Johnson, R., \& Vlissides, J. (1994). "Design Patterns: Elements of Reusable Object-Oriented Software". Addison-Wesley.}
\item \textbf{Qt Design Patterns} - Dokumentasi Qt\footnote{Qt Company. (2023). "Qt Design Patterns". https://doc.qt.io/qt-6/design-patterns.html}
\item \textbf{Head First Design Patterns} - Freeman \& Robson\footnote{Freeman, E., \& Robson, E. (2004). "Head First Design Patterns". O'Reilly Media.}
\item \textbf{Modern C++ Design} - Alexandrescu\footnote{Alexandrescu, A. (2001). "Modern C++ Design: Generic Programming and Design Patterns Applied". Addison-Wesley.}
\end{itemize}

\section{üéâ Kesimpulan}

Design patterns adalah alat yang powerful untuk membuat kode yang lebih baik, lebih maintainable, dan lebih reusable. Qt sudah mengimplementasikan banyak pattern yang bisa kita pelajari dan gunakan.

\begin{center}
\textbf{Design patterns membantu kita menulis kode yang lebih baik dan lebih mudah dipahami!} üé®‚ú®
\end{center}

\vspace{1cm}

\begin{center}
\textit{--- Bab selanjutnya: Casting dan Database ---}
\end{center} 